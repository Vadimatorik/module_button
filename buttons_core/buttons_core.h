#pragma once

#include "user_os.h"

namespace Button {

#define	BUTTON_BASE_TASK_STACK_SIZE			200

/*!
 *	\brief		Данная структура описывает механизм
 *				поведения в случае возникновения
 *				какой-либо ситуации.
 *				Пример: произошло короткое
 *				нажатие, долгое нажатие,
 *				клавишу отпустили и т.д.
 */
struct Event {
	/*!
	 *	\brief		Указатель на семафор, который будет
	 *				отдан при возникновении события.
	 *				Может быть nullptr, тогда при
	 *				возникновении события не будет
	 *				выдачи семафора.
	 */
	USER_OS_STATIC_BIN_SEMAPHORE*		s;

	/*!
	 *	\brief		Указатель на очередь, в которую
	 *				будет положено значение из переменной
	 *				v в случае возникновения события.
	 *				Может быть nullptr, тогда при
	 *				возникновении события сообщение в
	 *				очередь положено не будет.
	 */
	USER_OS_STATIC_QUEUE*				q;
	uint8_t								v;
};

/*!
 *	\brief		Флаги состояния  одной клавиши.
 *				Структура является системной.
 */
struct Status {
	bool								press;					/// Флаг состояния нажатия до текущей проверки (окончание предыдущей).
	bool								bounce;					/// Флаг состояния проверки на дребезг: true - идет (еще идет), false - пройдена успешно.
	bool								eventLongClick;			/// Флаг события "произошло длительное нажатие": true - произошло, false - нет.
	uint32_t							bounceTime;				/// Оставшееся время до окончания проверки на дребезг (в мс).
	uint32_t							buttonLongClickTime;	/// Сколько прошло времени с момента нажатия клавиши (идет начиная с проверки дребезга).
};

struct OneButtonCfg {
	/*!
	 *	\brief		Уникальный идентификатор клавиши.
	 *				При обращении к физическому уровню
	 *				по нему будет осуществляться запрос
	 *				состояния конкретной клавиши.
	 *
	 *				Данный идентификатор задается
	 *				пользователем и может иметь
	 *				любое неповторяющееся в пределах
	 *				одного модуля значение.
	 */
	uint8_t				id;

	// Отслеживание дребезга контактов. Количество мс, для стабилизации нажатия (защита от дребезга).
	/*!
	 *	\brief		Время отслеживания дребезга контактов.
	 *				Количество мс, для стабилизации
	 *				нажатия (защита от дребезга).
	 *				Указывается в миллисекундах.
	 */
	uint8_t				stabilizationTimeMs;

	/*!
	 *	\brief		Отслеживание долгого нажатия.
	 *				Время нажатия, после которого
	 *				кнопка считается долго зажатой.
	 *				В миллисекундах.
	 *				Если тут 0, то долгое нажатие
	 *				не детектируется.
	 */
	uint8_t				longPressDetectionTimeS;

	/*!
	 *	\brief		Кнопку нажали (прошла проверку дребезга).
	 */
	Button::Event		press;

	/*!
	 *	\brief		Кнопку отпустили до того, как
	 *				прошел период longPressDetectionTimeS.
	 *				Если период longPressDetectionTimeS
	 *				был задан как 0, то после любого по
	 *				времени нажатия будет выдача
	 *				этого события.
	 */
	Button::Event		click;

	/*!
	 *	\brief		Кнопку держат дольше
	 *				longPressDetectionTimeS.
	 */
	Button::Event		longPress;

	/*!
	 *	\brief		Кнопку отпустили после того, как
	 *				прошел период longPressDetectionTimeS.
	 *				Если период longPressDetectionTimeS
	 *				был задан как 0, то по окончании
	 *				нажатия будет выдано событие
	 *				click.
	 */
	Button::Event		longClick;
};

struct BaseCfg {
	/*!
	 *	\brief		Пауза между опросами всех кнопок.
	 */
	uint8_t			taskDelayMs;

	/*!
	 *	\brief		Приоритет задачи, работающий с кнопками.
	 */
	uint8_t			taskPrio;

	/*!
	 *	\brief		Массив конфигураций клавиш.
	 */
	OneButtonCfg*	cfgArray;

	/*!
	 *	\brief		Количество кнопок (размер массива).
	 */
	uint8_t			cfgArraySize;

	/*!
	 *	\brief		Метод возвращает текущее состояние
	 *				клавиши (нажата/отпущена).
	 *				В качестве id используется число
	 *				полученное из структуры конфигурации
	 *				кнопки (поле id).
	 */
	bool	( *getButtonState )				(	uint8_t		id	);
};

class Base {
public:
	Base	(	const BaseCfg*		const cfg	);

private:
	static	void	task			(	void*		obj	);

private:
	/*!
	 *`	\brief		Обработка клавиши в случае,
	 *`				если клавиша в данный момент нажата.
	 */
	void processPress				(	uint32_t	bNumber	);

	/*!
	 *	\brief		бработка клавиши в случае,
	 *				если клавиша в данный момент отпущена.
	 */
	void processNotPress			(	uint32_t	bNumber	);

private:
	USER_OS_STATIC_STACK_TYPE			taskStack[ BUTTON_BASE_TASK_STACK_SIZE ] = { 0 };
	USER_OS_STATIC_TASK_STRUCT_TYPE		taskStruct;

private:
	const BaseCfg*			const cfg;
	Status*					s;

};

}
